%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This script post-processes FRC measurements from [1]. The test rig
% involves two similar cantilevered beams undergoing soft collisions via 
% a unilateral spring. The test methods are described in [1].
% 
% With this script, plots similar to those in Figures 11, 12 and B.1 in 
% [1] are generated. In its present form, it requires the file 
% 'Backbone_3.mat' generated by 'VIBeams_POSTPROCESSING_Backbones.m'. So 
% please run that first before running this script.
% 
% The corresponding data has to be available in the BASEFOLDER specified 
% by the user. The data can be downloaded from [2]. For information on the 
% data file names and content structure, see README in [2]. Besides
% measurement data, you also find CAD files and technical drawings, as well
% as a PDF indicating the measurement points in [2].
% 
% REFERENCES
% [1] https://doi.org/10.25518/2684-6500.180
% [2] https://doi.org/10.18419/darus-4504
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This file is part of NLtest available via
% https://github.com/maltekrack/NLtest.
% 
% COPYRIGHT (C) 2024
%   Malte Krack (malte.krack@ila.uni-stuttgart.de) 
%   Maren Scheel (maren.scheel@ila.uni-stuttgart.de)
%   Lukas Woiwode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clearvars;
close all;
clc;

filepath = fileparts(mfilename("fullpath"));
cd(filepath);

addpath('../../SRC');
%% KEY USER INPUT

% Folder with measurements
BASEFOLDER = './DATA/measurements';

% Nominal parameters 
om_linref = 28.2*2*pi;
gap = .17e-3; % for illustration

% Base acceleration levels and number of FRC tests
BaseAcc_m_s2 = [.02 .0280 .0305];
num_SteppedFrequencyRuns = [1 1 3];
num_SteppedPhaseRuns = [0 3 2];

% Specify options for post-processing
options.computeFourierCoefficients = 'FFT'; 
options.target_number_of_last_periods_of_hold_phase_to_process = 70;
levelRelTolerance = 2.5e-2; % 2.5\% tolerance on excitation level
%% LOAD DATA FROM STEPPED FREQUENCY TESTS AND ESTIMATE FOURIER COEFFICIENTS
SteppedFrequencyTests = cell(length(BaseAcc_m_s2),1);
for LEVEL=1:length(BaseAcc_m_s2)
    SteppedFrequencyTests{LEVEL} = struct(...
        'frequency_Hz',cell(num_SteppedFrequencyRuns(LEVEL),1),...
        'Excitation_m_s',cell(num_SteppedFrequencyRuns(LEVEL),1),...
        'Response_m_s',cell(num_SteppedFrequencyRuns(LEVEL),1),...
        'arespMAX_m',cell(num_SteppedFrequencyRuns(LEVEL),1),...
        'arespMIN_m',cell(num_SteppedFrequencyRuns(LEVEL),1));
    for RUN=1:num_SteppedFrequencyRuns(LEVEL)
        disp(['Processing stepped frequency test, level ' ...
            num2str(LEVEL) ', run ' num2str(RUN) '.']);

        % Generate file name
        fname = [BASEFOLDER '/FRC_SteppedFrequency_' ...
            strrep(num2str(BaseAcc_m_s2(LEVEL)),'.','_') 'ms2_'...
            num2str(RUN)];

        % Load time-frequency profile
        steps = readmatrix([fname '_frequency_steps']);

        % Load control signals and SPV measurements
        data = readmatrix([fname '_dspace']);
        time_s = data(:,1);
        excitation_m_s = data(:,3);
        response_m_s = data(:,4);
        instantaneousFrequency_Hz = data(:,5);

        % DETERMINE HOLD PHASES
        % Interpret step intput
        step_times = steps(:,1);
        step_values = steps(:,2);
        % Truncate according to available data
        data_available = step_times>=time_s(1) & step_times<=time_s(end);
        step_times = step_times(data_available);
        step_values = step_values(data_available);
                % Identify hold phases and keep those that are long enough
        isStartOfHoldPhase = find(diff(step_values)==0);
        holdPhase_start = step_times(isStartOfHoldPhase);
        holdPhase_end = step_times(isStartOfHoldPhase+1);
        % If hold time is too short, scrap hold phase
        isLongEnough = (holdPhase_end-holdPhase_start).*step_values(isStartOfHoldPhase+1) > ...
            options.target_number_of_last_periods_of_hold_phase_to_process;
        holdPhase_end = holdPhase_end(isLongEnough);
        holdPhase_start = holdPhase_start(isLongEnough);
        numHoldPhases = size(holdPhase_end,1);
                % create flagSettling needed for postprocessing
        flagSettling = false(size(time_s));
        for iHold = 1:numHoldPhases
            flagtemp = holdPhase_start(iHold)<=time_s & time_s<= holdPhase_end(iHold);
            flagSettling = flagSettling | flagtemp;
        end
        flagSettling(1)=false; % start with a non-recording phase

        % Estimate Fourier coefficients
        [frequency_Hz,Excitation_m_s,Response_m_s,indPROCESS] = ...
            estimateFourierCoefficientsFromSteppedSine(time_s,...
            instantaneousFrequency_Hz,...
            excitation_m_s,response_m_s,flagSettling,...
            options);
                
        % Determine minimum and maximum response level
        arespMAX = zeros(size(frequency_Hz)); arespMIN = arespMAX;
        for iHold=1:size(indPROCESS,1)
            % Extract time, frequency and response velocity for considered
            % time span
            time = time_s(indPROCESS(iHold,:));
            freq = frequency_Hz(iHold);
            resp = response_m_s(indPROCESS(iHold,:));
            % Sample complete periods, interpolate
            nPer = floor(freq*(time(end)-time(1)));
            npper = 200;
            time_ = time(1) + (0:nPer*npper-1)/(npper*freq);
            resp_ = interp1(time,resp,time_);
            % Least-squares estimate of harmonic per period
            resp_ = reshape(resp_,npper,nPer);
            tau = linspace(0,2*pi,npper+1)'; tau = tau(1:end-1);
            aresp = 2*abs(exp(1i*tau)\resp_);
            % Take max/min and convert from velocity to displacement
            arespMAX(iHold) = max(aresp)/(2*pi*freq);
            arespMIN(iHold) = min(aresp)/(2*pi*freq);
        end

        % Remove points that do not meet the excitation level tolerance
        meetsTolerance = abs( abs(Excitation_m_s(:,2).*2*pi.*frequency_Hz) / ...
            BaseAcc_m_s2(LEVEL) - 1 ) < levelRelTolerance;
        frequency_Hz = frequency_Hz(meetsTolerance);
        Excitation_m_s = Excitation_m_s(meetsTolerance,:);
        Response_m_s = Response_m_s(meetsTolerance,:);
        arespMAX = arespMAX(meetsTolerance);
        arespMIN = arespMIN(meetsTolerance);

        % Store results
        results = struct('frequency_Hz',frequency_Hz,...
            'Excitation_m_s',Excitation_m_s,...
            'Response_m_s',Response_m_s,...
            'arespMAX_m',arespMAX,'arespMIN_m',arespMIN);
        SteppedFrequencyTests{LEVEL}(RUN) = results;
    end
end
%% LOAD DATA FROM STEPPED PHASE TESTS AND ESTIMATE FOURIER COEFFICIENTS
SteppedPhaseTests = cell(length(BaseAcc_m_s2),1);
for LEVEL=1:length(BaseAcc_m_s2)
    SteppedPhaseTests{LEVEL} = struct(...
        'frequency_Hz',cell(num_SteppedPhaseRuns(LEVEL),1),...
        'Excitation_m_s',cell(num_SteppedPhaseRuns(LEVEL),1),...
        'Response_m_s',cell(num_SteppedPhaseRuns(LEVEL),1));
    for RUN=1:num_SteppedPhaseRuns(LEVEL)
        disp(['Processing stepped phase test, level ' ...
            num2str(LEVEL) ', run ' num2str(RUN) '.']);

        % Generate file name
        fname = [BASEFOLDER '/FRC_SteppedPhase_' ...
            strrep(num2str(BaseAcc_m_s2(LEVEL)),'.','_') 'ms2_'...
            num2str(RUN)];

        % Load time-phase profile
        steps = readmatrix([fname '_phase_steps']);

        % Load control signals and SPV measurements
        data = readmatrix([fname '_dspace']);
        time_s = data(:,1);
        excitation_m_s = data(:,3);
        response_m_s = data(:,4);
        instantaneousFrequency_Hz = data(:,5);

        % DETERMINE HOLD PHASES
        % Interpret step intput
        step_times = steps(:,1);
        step_values = steps(:,2);
        % Truncate according to available data
        data_available = step_times>=time_s(1) & step_times<=time_s(end);
        step_times = step_times(data_available);
        step_values = step_values(data_available);
                % Identify hold phases and keep those that are long enough
        isStartOfHoldPhase = find(diff(step_values)==0);
        holdPhase_start = step_times(isStartOfHoldPhase);
        holdPhase_end = step_times(isStartOfHoldPhase+1);
        % If hold time is too short, scrap hold phase
        isLongEnough = (holdPhase_end-holdPhase_start)*(om_linref/2/pi) > ...
            options.target_number_of_last_periods_of_hold_phase_to_process;
        holdPhase_end = holdPhase_end(isLongEnough);
        holdPhase_start = holdPhase_start(isLongEnough);
        numHoldPhases = size(holdPhase_end,1);
                % create flagSettling needed for postprocessing
        flagSettling = false(size(time_s));
        for iHold = 1:numHoldPhases
            flagtemp = holdPhase_start(iHold)<=time_s & time_s<= holdPhase_end(iHold);
            flagSettling = flagSettling | flagtemp;
        end
        flagSettling(1)=false; % start with a non-recording phase

        % Estimate Fourier coefficients
        [frequency_Hz,Excitation_m_s,Response_m_s] = ...
            estimateFourierCoefficientsFromSteppedSine(time_s,...
            instantaneousFrequency_Hz,...
            excitation_m_s,response_m_s,flagSettling,...
            options);
        
        % Remove points that do not meet the excitation level tolerance
        meetsTolerance = abs( abs(Excitation_m_s(:,2).*2*pi.*frequency_Hz) / ...
            BaseAcc_m_s2(LEVEL) - 1 ) < levelRelTolerance;
        frequency_Hz = frequency_Hz(meetsTolerance);
        Excitation_m_s = Excitation_m_s(meetsTolerance,:);
        Response_m_s = Response_m_s(meetsTolerance,:);

        % Store results
        results = struct('frequency_Hz',frequency_Hz,...
            'Excitation_m_s',Excitation_m_s,...
            'Response_m_s',Response_m_s);
        SteppedPhaseTests{LEVEL}(RUN) = results;
    end
end
% % Save results
% save('results/FRCs.mat','SteppedFrequencyTests',...
%     'SteppedPhaseTests');
% load('results/FRCs.mat','SteppedFrequencyTests',...
%     'SteppedPhaseTests');
%% FIGURE 11

figure(1); hold on;
set(gca,'xlim',[.98 1.04],'xtick',.98:.01:1.04,...
    'ylim',[.8 1.8],'ytick',.8:.2:1.8);
xlabel('\Omega/\omega_1^{RB}');
ylabel('a_{resp}/g');
figure(2); hold on;
set(gca,'xlim',[.98 1.04],'xtick',.98:.01:1.04,...
    'ylim',[-180 0]);
xlabel('\Omega/\omega_1^{RB}');
ylabel('phase lag in °');

% Stepped frequency, highest excitation level, run 1
FRC = SteppedFrequencyTests{end}(1);
freq = FRC.frequency_Hz;
aresp = abs(FRC.Response_m_s(:,2)./(2*pi*freq));
phase = angle(FRC.Response_m_s(:,2)./...
    FRC.Excitation_m_s(:,2))*180/pi;
figure(1); 
fill([freq;flipud(freq)]/(om_linref/(2*pi)),...
    [FRC.arespMAX_m;flipud(FRC.arespMIN_m)]/gap,...
    0.85*[1 1 1],'EdgeColor', 'none');
plot(freq/(om_linref/(2*pi)),aresp/gap,...
    '.-','linewidth',1.5,'markersize',10,'Color',0.5*[1 1 1])
figure(2); plot(freq/(om_linref/(2*pi)),phase,...
    '.-','linewidth',1.5,'markersize',10,'Color',0.5*[1 1 1])

% Stepped phase, highest excitation level, all runs
for RUN=1:length(SteppedPhaseTests{end})
    FRC = SteppedPhaseTests{end}(RUN);
    freq = FRC.frequency_Hz;
    aresp = abs(FRC.Response_m_s(:,2)./(2*pi*freq));
    phase = angle(FRC.Response_m_s(:,2)./...
        FRC.Excitation_m_s(:,2))*180/pi;
    figure(1); plot(freq/(om_linref/(2*pi)),aresp/gap,...
        '.m','linewidth',1.5,'markersize',10);
    figure(2); plot(freq/(om_linref/(2*pi)),phase,...
        '.m','linewidth',1.5,'markersize',10)
end

% Stepped phase, medium excitation level, all runs
for RUN=1:length(SteppedPhaseTests{2})
    FRC = SteppedPhaseTests{2}(RUN);
    freq = FRC.frequency_Hz;
    aresp = abs(FRC.Response_m_s(:,2)./(2*pi*freq));
    phase = angle(FRC.Response_m_s(:,2)./...
        FRC.Excitation_m_s(:,2))*180/pi;
    figure(1); plot(freq/(om_linref/(2*pi)),aresp/gap,...
        '.c','linewidth',1.5,'markersize',10);
    figure(2); plot(freq/(om_linref/(2*pi)),phase,...
        '.c','linewidth',1.5,'markersize',10)
end

% Backbone, run 3
backbone = load('results/Backbone_3.mat');
freq = backbone.modalFrequency_Hz;
backbone.Response_m_s_1H = NaN(length(freq),1);
for iHold = 1:length(freq)
    backbone.Response_m_s_1H(iHold) = backbone.Response_m_s{iHold}(2);
end
aresp = abs(backbone.Response_m_s_1H./(1i*2*pi*freq));
phase = angle(backbone.Response_m_s_1H./...
    backbone.Excitation_m_s(:,2))*180/pi;
figure(1); plot(freq/(om_linref/(2*pi)),aresp/gap,'g-','linewidth',1.5);
figure(2); plot(freq/(om_linref/(2*pi)),phase,'g-','linewidth',1.5);
%% FIGURE 12
figure(3); hold on;
set(gca,'xlim',[.98 1.04],'xtick',.98:.01:1.04,...
    'ylim',[.8 1.8],'ytick',.8:.2:1.8);
xlabel('\Omega/\omega_1^{RB}');
ylabel('a_{resp}/g');
figure(4); hold on;
set(gca,'xlim',[.98 1.04],'xtick',.98:.01:1.04,...
    'ylim',[-180 0]);
xlabel('\Omega/\omega_1^{RB}');
ylabel('phase lag in °');

% NM-ROM, medium excitation level
om = 2*pi*backbone.modalFrequency_Hz;
D = backbone.modalDampingRatio;
aresp = abs(backbone.Response_m_s_1H./(1i*om));
Qbabs = abs(backbone.Excitation_m_s(:,2)./(1i*om));
arespNM = linspace(aresp(1),aresp(end),1e4);
om = interp1(aresp,om,arespNM,'PCHIP');
D = interp1(aresp,D,arespNM,'PCHIP');
Qbabs = interp1(aresp,Qbabs,arespNM,'PCHIP');
rad = (2*D*BaseAcc_m_s2(2)./(om.^2.*Qbabs)).^2 - ...
    ( 1 - (1-2*D.^2).^2 );
OmL = sqrt(om.^2.*( 1-2*D.^2 - sqrt(rad) ));
OmR = sqrt(om.^2.*( 1-2*D.^2 + sqrt(rad) ));
phaseL = -180/pi*angle(-OmL.^2+1i*OmL.*2.*D.*om+om.^2);
phaseR = -180/pi*angle(-OmR.^2+1i*OmR.*2.*D.*om+om.^2);

% Illustrate results
figure(3); 
plot(OmL(rad>=0)/om_linref,arespNM(rad>=0)/gap,'r.');
plot(OmR(rad>=0)/om_linref,arespNM(rad>=0)/gap,'r.');
figure(4); 
plot(OmL(rad>=0)/om_linref,phaseL(rad>=0),'r.');
plot(OmR(rad>=0)/om_linref,phaseR(rad>=0),'r.');

% Stepped phase, medium excitation level, all runs
for RUN=1:length(SteppedPhaseTests{2})
    FRC = SteppedPhaseTests{2}(RUN);
    freq = FRC.frequency_Hz;
    aresp = abs(FRC.Response_m_s(:,2)./(2*pi*freq));
    phase = angle(FRC.Response_m_s(:,2)./...
        FRC.Excitation_m_s(:,2))*180/pi;
    figure(3); plot(freq/(om_linref/(2*pi)),aresp/gap,...
        '.k','linewidth',1.5,'markersize',10);
    figure(4); plot(freq/(om_linref/(2*pi)),phase,...
        '.k','linewidth',1.5,'markersize',10)
end

figure(5); hold on;
set(gca,'xlim',[.98 1.04],'xtick',.98:.01:1.04,...
    'ylim',[.8 1.8],'ytick',.8:.2:1.8);
xlabel('\Omega/\omega_1^{RB}');
ylabel('a_{resp}/g');
figure(6); hold on;
set(gca,'xlim',[.98 1.04],'xtick',.98:.01:1.04,...
    'ylim',[-180 0]);
xlabel('\Omega/\omega_1^{RB}');
ylabel('phase lag in °');

% NM-ROM, highest excitation level
rad = (2*D*BaseAcc_m_s2(end)./(om.^2.*Qbabs)).^2 - ...
    ( 1 - (1-2*D.^2).^2 );
OmL = sqrt(om.^2.*( 1-2*D.^2 - sqrt(rad) ));
OmR = sqrt(om.^2.*( 1-2*D.^2 + sqrt(rad) ));
phaseL = -180/pi*angle(-OmL.^2+1i*OmL.*2.*D.*om+om.^2);
phaseR = -180/pi*angle(-OmR.^2+1i*OmR.*2.*D.*om+om.^2);

% Illustrate results
figure(5); 
plot(OmL(rad>=0)/om_linref,arespNM(rad>=0)/gap,'r.');
plot(OmR(rad>=0)/om_linref,arespNM(rad>=0)/gap,'r.');
figure(6); 
plot(OmL(rad>=0)/om_linref,phaseL(rad>=0),'r.');
plot(OmR(rad>=0)/om_linref,phaseR(rad>=0),'r.');

% Stepped phase, highest excitation level, all runs
for RUN=1:length(SteppedPhaseTests{3})
    FRC = SteppedPhaseTests{3}(RUN);
    freq = FRC.frequency_Hz;
    aresp = abs(FRC.Response_m_s(:,2)./(2*pi*freq));
    phase = angle(FRC.Response_m_s(:,2)./...
        FRC.Excitation_m_s(:,2))*180/pi;
    figure(5); plot(freq/(om_linref/(2*pi)),aresp/gap,...
        '.k','linewidth',1.5,'markersize',10);
    figure(6); plot(freq/(om_linref/(2*pi)),phase,...
        '.k','linewidth',1.5,'markersize',10)
end
%% FIGURE B.1
figure(7); hold on;
set(gca,'xlim',[.99 1.035],'xtick',.98:.01:1.04,...
    'ylim',[0 1.6]);
xlabel('\Omega/\omega_1^{RB}');
ylabel('a_{resp}/g');

% Stepped frequency, all excitation levels, run 1
COLOR = {'b','y','k'};
for LEVEL=1:length(SteppedFrequencyTests)
    FRC = SteppedFrequencyTests{LEVEL}(1);
    freq = FRC.frequency_Hz;
    aresp = abs(FRC.Response_m_s(:,2)./(2*pi*freq));
    fill([freq;flipud(freq)]/(om_linref/(2*pi)),...
        [FRC.arespMAX_m;flipud(FRC.arespMIN_m)]/gap,...
        0.85*[1 1 1],'EdgeColor', 'none');
    plot(freq/(om_linref/(2*pi)),aresp/gap,...
        '.-','linewidth',1.5,'markersize',10,'Color',COLOR{LEVEL});
end

figure(8); hold on;
set(gca,'xlim',[.985 1.01],'ylim',[0 1.5]);
xlabel('\Omega/\omega_1^{RB}');
ylabel('a_{resp}/g');

% Stepped frequency, highest excitation level, run 2-3
LSPEC = {'','k-.','k-o'};
for RUN=2:3
    FRC = SteppedFrequencyTests{end}(RUN);
    freq = FRC.frequency_Hz;
    aresp = abs(FRC.Response_m_s(:,2)./(2*pi*freq));
    fill([freq;flipud(freq)]/(om_linref/(2*pi)),...
        [FRC.arespMAX_m;flipud(FRC.arespMIN_m)]/gap,...
        0.85*[1 1 1],'EdgeColor', 'none');
    plot(freq/(om_linref/(2*pi)),aresp/gap,...
        LSPEC{RUN},'linewidth',1.5);
end
